---
title: "Guided Exercise 12 - Databases"
output: 
  tufte::tufte_html:
    css: ../ex.css
    tufte_variant: "envisioned"
    highlight: pygments
link-citations: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "")
library(tidyverse)
theme_set(theme_bw())
options(scipen = 5) # encourage metrics to print in fixed-point notation
options(dplyr.summarise.inform = FALSE) # silence a warning message
```

The goal of this exercise is to learn about how to work with databases and particularly the SQL query language.

## Getting started

Pull your portfolio repo as usual.

We'll be working with the flights data from our textbook. Here's the code to connect to the database:

```{r}
library(tidyverse)
library(DBI)
db <- DBI::dbConnect(RMariaDB::MariaDB(), dbname = "airlines", host = "mdsr.cdc7tgkkqd0n.us-east-1.rds.amazonaws.com", 
    user = "mdsr_public", password = "ImhsmflMDSwR")
```

And we'll get references to two specific tables we'll be working with.

```{r}
flights <- tbl(db, "flights")
carriers <- tbl(db, "carriers")
```

Each of those *behaves* like a `tibble` (data frame), but it's actually a reference to remote data.

```{r}
flights %>% head()
```

The tool that makes this possible is called [`dbplyr`](https://dbplyr.tidyverse.org/). The objects it gives us to work with are *lazy*: they don't actually fetch the data until we absolutely need it. They're lazy *queries* in that to get the data we're going to ask the database for data in a language called "SQL". (Structured Query Language).

We can ask for the query that would be executed using `show_query`.

```{r}
flights %>% show_query()
```


```{r}
flights %>% 
  filter(year == 2016) %>% 
  show_query()
```

::: {.exercises}

1. Based only on looking at the above, what SQL expression corresponds to `filter`?

Also, since queries are lazy, even finding out how many rows is expensive, since we'd have to run that query. So, somewhat surprisingly:

```{r}
nrow(flights)
```

But we can use summary functions!

```{r}
flights %>% 
  filter(year == 2016, month == 11, distance > 1000) %>% 
  summarize(
    n = n(),
    mean_dep_delay = mean(dep_delay, na.rm = TRUE)
  ) %>% show_query()
```

```{r}
flights %>% 
  filter(year == 2016, month == 11, distance > 2000) %>% 
  summarize(n = n(), mean_dep_delay = mean(dep_delay, na.rm = TRUE)) 
```

2. Based on the above, how does SQL express `n` and `mean`?

3. What years of data are stored in the `flights` table? Do this by summarizing the `min` and `max` of the `year` column. (Before actually executing this query, get the instructor to verify your query so that you don't overload the shared server.)


```{r echo=FALSE}
flights %>% 
  summarize(first_year = min(year, na.rm = TRUE), last_year = max(year, na.rm = TRUE)) %>% 
  collect()
```

4. How many flights arrived in JFK (`dest` is `JFK`) in November of 2016?

```{r echo=FALSE}
subflights <- flights %>% 
  filter(year == 2016, month == 11, dest == 'JFK')
subflights %>% 
  summarize(n = n()) %>%
  collect()
```

5. In that period (November of 2016 for JFK), how many flights arrived for each `carrier`? Sort the result by decreasing number of flights.

```{r echo=FALSE}
subflights %>% 
  group_by(carrier) %>% 
  summarize(n = n()) %>% 
  arrange(desc(n)) %>% 
  collect()
```

6. Look at the SQL query for the previous exercise. How does SQL express `group_by`? How does SQL express `arrange`?

```{r echo=FALSE}
subflights %>% 
  group_by(carrier) %>% 
  summarize(n = n()) %>%
  arrange(desc(n)) %>% 
  show_query()
```

7. In that same period (November of 2016 for JFK), what fraction of flights from each carrier were on time? Consider a flight to be on time if its `arr_delay` is no more than 15 (minutes).

The easiest way to do this is the "sum-as-count" pattern: `sum(arr_delay <= 15)`.

Ask the instructor before running this query.

```{r echo=FALSE}
subflights %>% 
  group_by(carrier) %>% 
  summarize(n = n(), frac_ontime = sum(arr_delay <= 15, na.rm = TRUE) / n()) %>%
  arrange(desc(n))
```

8. Join the result to the `carriers` table to look up the carrier name for each carrier code.

:::

## Additional notes

* CSVs are useful to store and exchange *small* to *medium* amounts of "static" data
* relational databases are useful when data is growing / changing (especially from multiple sources)
* relational databases are useful when multiple systems or stakeholders need the same data
* relational databases are useful when data is too big to fit in memory, since RDBMS's can often automatically figure out how to compute things in a "distributed" or "streaming" way
  * So-called NoSQL systems, like MongoDB and Firebase, have been popular in recent years, but SQL remains pervasive in industry because of its robustness, consistency, and performance.
* Other SQL tutorials:
  * [Codecademy](https://www.codecademy.com/learn/learn-sql)
  * [w3schools](https://www.w3schools.com/sql/)
* Syntax reference
  * I kinda like the "railway diagrams" in the [sqlite syntax documentation](https://www.sqlite.org/lang.html) (e.g., for the [SELECT statement](https://www.sqlite.org/lang_select.html))
  * [Codecademy has a reference](https://www.codecademy.com/articles/sql-commands)
  * [TutorialsPoint](https://www.tutorialspoint.com/sql/sql-syntax.htm)
* [sqlfiddle](http://sqlfiddle.com/)

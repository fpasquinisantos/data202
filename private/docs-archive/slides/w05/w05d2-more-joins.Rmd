---
title: "Practicing and Extending Joins"
author: "DATA 202 21FA"
output:
  xaringan::moon_reader:
    css: ["xaringan-themer.css", "slides.css"]
    lib_dir: libs
    nature:
      ratio: "4:3"
      highlightLines: true
      highlightStyle: solarized-light
      countIncrementalSlides: false
---

```{r child = "../slide-setup.Rmd"}
```

```{r packages, include=FALSE}
knitr::opts_chunk$set(comment = "")
options(dplyr.print_max = 10)

library(tidyverse)
xaringanExtra::use_freezeframe(overlay = TRUE)
```

## Reminders

- Data Science Firepit Tonight!

Also:

- Quiz 5 closes tonight
- Homework 3 due Friday
- Discussion Forum replies due tomorrow

---

## Preview: replication project


---

## Gradescope trial

See Moodle.

---

## Q&A

> Can't you rewrite any `right_join` as a flipped `left_join`?

Yes! It's mostly convenience (piped data comes in on *left*).

> Can we join more than 2 tables at once?

SQL? yes. `dplyr` makes you split it up though.

---

## Q: Why did we need `summarize()`?

```{r include=FALSE}
purchases <- tribble(
               ~customer_id,          ~item,
                         "c1",        "bread",
                         "c1",         "milk",
                         "c1",       "banana",
                         "c2",         "milk",
                         "c2", "toilet paper"
               )

prices <- tribble(
           ~item, ~price,
       "avocado",    0.5,
        "banana",   0.15,
         "bread",      1,
          "milk",    0.8,
  "toilet paper",      3
  )
```


.small[
```{r include=FALSE}
purchases_and_prices <- left_join(purchases, prices, by = "item")
purchases_and_prices
```
]

```{r}
purchases_and_prices %>% 
  summarize(total_revenue = sum(price)) #<<
```

```{r error=TRUE}
sum(price)
```

```{r}
sum(purchases_and_prices$price)
```

---

## Aside: vectors

So far we've always packaged vectors in data frames. But they can live on their own.

.pull-left[
```{r}
purchases_and_prices %>% select(price)
```
]
.pull-right[
```{r}
price_vec<- purchases_and_prices$price
price_vec
```
]

```{r}
typeof(price_vec)
```

---

## Relational Data

- Bring together data that may never have been brought together before
- Values:
  - No one source has a complete view of the world
  - We need each other ("one body, many parts")
- Helps us get a more holistic picture
  - people aren't just their transactions; they also live somewhere

---

## Example Applications

- Looking up abbreviations
- Connecting sales data to each customer's demographics
- Combining student data from Moodle, an online textbook, GitHub activity reports, ...

What others can you think of?

---

## Code Together: Flight Delays

```{r}
library(nycflights13)
```

```{r}
flights %>% 
  drop_na(arr_delay) %>% 
  group_by(carrier) %>% 
  summarize(avg_delay = mean(arr_delay)) %>% 
  arrange(desc(avg_delay)) %>% 
  left_join(airlines, by = "carrier") %>% 
  select(name, avg_delay)
```

---

# Multiple matches

.pull-left[
```{r echo=FALSE, out.width="30%", fig.align='center'}
include_graphics("img/left-join-extra.gif")
```
]

---

## Revenue by item?

.pull-left[
```{r eval=FALSE}
purchases
```

.smaller-table[
```{r echo = FALSE}
purchases %>% kable()
```
]
]
.pull-right[
```{r eval = FALSE}
prices
```

.smaller-table[
```{r echo=FALSE}
prices %>% kable()
```
]
]


---

## Revenue by item?

For each item, look up all sales data.

```{r}
prices %>% 
  left_join(purchases)
```

Notice: multiple rows for each item. Where did each one come from?

---

## Revenue by item?

```{r}
prices %>% 
  left_join(purchases) %>% 
  group_by(item) %>% 
  summarize(revenue = sum(price))
```

...but nobody bought any avocados!

---

## `inner` vs `left`

.pull-left[
```{r}
prices %>% 
  left_join(purchases)
```
]
.pull-right[
```{r}
prices %>% 
  inner_join(purchases)
```
]

---

## Put it together

```{r}
prices %>% 
  inner_join(purchases) %>% 
  group_by(item) %>% 
  summarize(revenue = sum(price))
```
---

## uh oh...

```{r include=FALSE}
purchases <- tibble::tribble(
               ~customer_id,          ~item,
                         "c1",        "bread",
                         "c1",         "milk",
                         "c1",       "bananas",
                         "c2",         "milk",
                         "c2", "toilet paper"
               )

prices <- tibble::tribble(
           ~item, ~price,
       "AVOCADO",    0.5,
        "BANANA",   0.15,
         "BREAD",      1,
          "MILK",    0.8,
  "TOILET_PAPER",      3
  )
```

.pull-left[
```{r echo = FALSE}
purchases %>% kable()
```
]
.pull-right[

```{r echo=FALSE}
prices %>% kable()
```

]

--

```{r}
purchases %>% 
  left_join(prices)
```

---

## Specifying keys

- Keys must match *exactly*
- Can join on multiple columns (first name **and** last name)
- Default join: columns with same names
- Specify what columns to use: `left_join(x, y, by = c("first_name", "last_name"))`

---

## Make a new key that *does* match

```{r}
prices_fixed <- prices %>% 
  mutate(item_norm = str_to_lower(item)) #<<
purchases %>%
  left_join(prices_fixed,
            by = c("item" = "item_norm")) #<<
```

---

## But still some mismatches

.pull-left[
```{r}
purchases %>%
  anti_join( #<<
    prices_fixed,
    by = c("item" = "item_norm"))
```
]

.pull-right[
```{r}
prices_fixed %>%
  anti_join(
    purchases,
    by = c("item_norm" = "item"))
```
]

---

## Manual massaging: `if_else`

```{r}
prices_fixed <- prices %>% 
  mutate(
    item_norm = str_to_lower(item),
    item_norm = if_else( #<<
      item_norm == "toilet_paper", "toilet paper", #<<
                                   item_norm) #<<
  )
purchases %>%
  left_join(prices_fixed, by = c("item" = "item_norm"))
```

---

## Manual massaging: `case_when`

```{r}
prices_fixed <- prices %>% 
  mutate(
    item_norm = str_to_lower(item),
    item_norm = case_when( #<<
      item_norm == "toilet_paper" ~ "toilet paper", #<<
      TRUE                        ~ item_norm) #<<
  )
purchases %>%
  left_join(prices_fixed, by = c("item" = "item_norm"))
```

---

## Easy to add cases

```{r}
prices_fixed <- prices %>% 
  mutate(
    item_norm = str_to_lower(item),
    item_norm = case_when(
      item_norm == "toilet_paper" ~ "toilet paper",
      item_norm == "banana"       ~ "bananas", #<<
      TRUE                        ~ item_norm)
  )
purchases %>%
  left_join(prices_fixed, by = c("item" = "item_norm"))
```

---

## Aside: Could you use a `join` for this instead?

Think about this on your own.

---

## `case_when`

.pull-left[
`if-elif` version (Python):

```python
if age < 0:
    return "invalid"
elif age < 18:
    return "child"
else:
    return "adult"
```
]

.pull-right[
`case_when` version:

```{r}
age <- 18
case_when(
  age < 0   ~ "invalid",
  age < 18  ~ "child",
  TRUE      ~ "adult"
)
```
]

* first to `True` wins in both versions
* `TRUE` corresponds to `else` (the default)

---

## `case_when` vectorizes

Like many R functions, it actually applies to all elements of a vector.

```{r}
age <- c(-1, 0, 17, 18) # a vector #<<
case_when(
  age < 0   ~ "invalid",
  age < 18  ~ "child",
  TRUE      ~ "adult"
)
```

---

## `case_when` vs `if_else`

You can write the same thing either way. Which do you prefer?

.pull-left[
`if_else`:
```{r}
if_else(
  age < 0, "invald",
  if_else(
    age < 18, "child",
    "other"))
```
]

.pull-right[
`case_when`:
```{r}
case_when(
  age < 0   ~ "invalid",
  age < 18  ~ "child",
  TRUE      ~ "adult"
)
```

]


---

## `case_when` in a data frame

```{r}
people <- tribble(
  ~name, ~age,
  "Allen Linford", -1,
  "Seb Dodds", 0,
  "Charleen Lockwood", 17,
  "Ridley Burgin", 18,
)
people %>% mutate(
  adult = case_when( #<<
    age < 0   ~ "invalid",
    age < 18  ~ "child",
    TRUE      ~ "adult"
  )
)
```

---

## The recoding pattern

```{r message=FALSE, eval=FALSE}
population <- read_csv("../../data/worldbank_sp_pop_totl.csv")
population %>% mutate(
  country = case_when(
    country == "United States" ~ "USA",  #<<
    iso3c == "GBR"             ~ "UK",   # LHS conditions may use different variables #<<
    TRUE                       ~ country # so can RHS #<<
  )
) %>% filter(str_starts(country, "U")) # Just to see the results
```

---

## More `case_when` tricks

See `?case_when` for how to:

* Deal with inconsistent data types
* Efficiently encode complicated conditionals
* Reuse `case_when` expressions by making a function

and more!

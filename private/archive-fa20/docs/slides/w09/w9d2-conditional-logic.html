<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Models with Conditional Logic</title>
    <meta charset="utf-8" />
    <meta name="author" content="K Arnold" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Models with Conditional Logic
### K Arnold

---




## Good Questions

&gt; Final project?

* No final exam, just final project.
* Should demonstrate modeling and validation
* Can optionally be an extension of your midterm project
* Can optionally be groups
* Proposals and matchmaking Moodle forum next week!

&gt; Was there a homework or lab this week?

No, to allow time to work on midterm project &amp; exam. But yes next week.

&gt; Can we review data wrangling stuff like joins and factors?

Review session during my office hours today (3-4pm). NH 295.

---

## Objectives

* Apply dummy encoding to add simple conditional logic to linear regression models
  * Explain how many columns get added in dummy encoding, and why
* Compare and contrast how linear regression and decision tree regression make predictions

---


```r
library(tidymodels)
data(ames, package = "modeldata")
ames &lt;- ames %&gt;% 
  filter(Gr_Liv_Area &lt; 4000, Sale_Condition == "Normal") %&gt;% 
  mutate(across(where(is.integer), as.double))
```


```r
set.seed(10) # Seed the random number generator
ames_split &lt;- initial_split(ames, prop = 2/3) # Split our data randomly
ames_train &lt;- training(ames_split)
ames_test &lt;- testing(ames_split)
```

We'll use one example home from the test set.


```r
example_home &lt;- ames_test %&gt;% slice(1)
example_home %&gt;% select(Gr_Liv_Area, Sale_Price)
```

```
## # A tibble: 1 x 2
##   Gr_Liv_Area Sale_Price
##         &lt;dbl&gt;      &lt;dbl&gt;
## 1        1656     215000
```

---


## What computations can a linear model do?

* *Add* up terms.
* Each term: *multiply* a number by a constant.

.pull-left[

```r
intercept &lt;- 15793
coef_living_area &lt;- 108
```



```r
intercept + coef_living_area * 1610
```

```
## [1] 189673
```
]

.pull-right[.small-code[

```r
ggplot(ames, aes(x = Gr_Liv_Area, y = Sale_Price)) +
  geom_point() +
  geom_hline(yintercept = example_home$Sale_Price, color = "red") +
  geom_vline(xintercept = example_home$Gr_Liv_Area, color = "red") +
  geom_point(data = example_home, color = 'red', size = 5) +
  geom_function(fun = function(x) intercept + coef_living_area * x, color = "blue")
```

&lt;img src="w9d2-conditional-logic_files/figure-html/price-vs-liv-area-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]]

---

## Do remodeled homes sell for more?

`Year Remod/Add`: Remodel date *(same as construction date if no remodeling or additions)*
(from dataset documentation)


```r
ames_2 &lt;- ames %&gt;% mutate(remodeled = Year_Remod_Add != Year_Built)
```


.small-code[

```r
ggplot(ames_2, aes(x = Gr_Liv_Area, y = Sale_Price, color = remodeled)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

&lt;img src="w9d2-conditional-logic_files/figure-html/remodeled-1.png" width="70%" style="display: block; margin: auto;" /&gt;
]

---

## Aside: the *sum-as-count* pattern

.pull-left[

```r
ames_2 %&gt;%
  group_by(remodeled) %&gt;% 
  summarize(n = n()) %&gt;% 
  mutate(proportion = n / sum(n))
```

```
## # A tibble: 2 x 3
##   remodeled     n proportion
##   &lt;lgl&gt;     &lt;int&gt;      &lt;dbl&gt;
## 1 FALSE      1303      0.540
## 2 TRUE       1109      0.460
```
]

.pull-right[

```r
ames_2 %&gt;% summarize(
  num_remodeled = sum(remodeled),
  prop_remodeled = mean(remodeled)
)
```

```
## # A tibble: 1 x 2
##   num_remodeled prop_remodeled
##           &lt;int&gt;          &lt;dbl&gt;
## 1          1109          0.460
```


Why does this work?



```r
as.numeric(remodeled[1:10])
```


```
##  [1] 0 0 0 0 1 0 0 0 1 0
```

&lt;!--
.small[This code needs to run in an environment where `remodeled` is defined, like
a `mutate` or `summarize` of our dataset.]
--&gt;

Its *sum* is the number of 1's (rows where the condition is true). Its *mean* is the sum divided by the total number,
i.e., the *proportion*.

]

---

## Conditional Logic: Simple Conditions

How could a *linear model* treat remodeled homes differently from non-remodeled?

```
if remodeled:
  Sale_Price = intercept_remodeled + coef_sqft * Gr_Liv_Arera
else:
  Sale_Price = intercept_other + coef_sqft * Gr_Liv_Arera
```

--

### Solution: "**dummy encoding**"

```
Sale_Price = 
   intercept_other 
   + coef_remodeled * (1 if remodeled)
   + coef_sqft      * Gr_Liv_Area
```

---


```r
ames_train_2 &lt;- ames_train %&gt;% 
  mutate(remodeled = as_factor(Year_Built != Year_Remod_Add))
```


---

.small[


```r
ames_recipe_3 &lt;- 
  recipe(Sale_Price ~ Gr_Liv_Area + remodeled, data = ames_train_2) %&gt;% 
* step_dummy(remodeled) %&gt;%
  #step_range(all_numeric(), -all_outcomes(), min = 0, max = 1) %&gt;%
  prep()
baked_ames_train &lt;- 
  ames_recipe_3 %&gt;% bake(new_data = ames_train_2)
baked_ames_train %&gt;% head(5) %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; Gr_Liv_Area &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Sale_Price &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; remodeled_TRUE. &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 896 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 105000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1329 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 172000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1629 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 189900 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 1 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1604 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 195500 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1804 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 189000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]

Why are is there no column for `remodeled_FALSE`?

---

## Models with dummy variables can be fit as normal

.small[

```r
ames_model_2 &lt;- linear_reg() %&gt;% set_engine("lm") %&gt;% 
  fit(Sale_Price ~ ., data = baked_ames_train)
ames_model_2 %&gt;% tidy() %&gt;% select(term, estimate) %&gt;% kable()
```



|term            |    estimate|
|:---------------|-----------:|
|(Intercept)     |  22643.4248|
|Gr_Liv_Area     |    109.1132|
|remodeled_TRUE. | -18424.0789|
]

```
Sale_Price = 
22643.42 
   + 109.1132 * Gr_Liv_Area
   + -18424.08  * (1 if remodeled)
```

or, in "code":

```
if remodeled:
  Sale_Price = 22643.4 + 109.1 * Gr_Liv_Arera - -18424.1 * (1)
  Sale_Price = (22643.4 - -18424.1) + 109.1 * Gr_Liv_Arera
else:
  Sale_Price = 22643.4 + 109.1 * Gr_Liv_Arera
```

---


```r
ggplot(baked_ames_train, aes(x = Gr_Liv_Area, y = Sale_Price, color = remodeled_TRUE.)) +
  geom_point() +
  geom_function(fun = function(x) (22643.4248 - 18424.0789) + 109.1132 * x, color = "blue") +
  geom_function(fun = function(x) 22643.4248 + 109.1132 * x, color = "green")
```

&lt;img src="w9d2-conditional-logic_files/figure-html/price-vs-liv-area-remodeled-1.png" width="100%" style="display: block; margin: auto;" /&gt;

---

## More than two options

```
Bldg Type (Nominal): Type of dwelling
       1Fam	Single-family Detached	
       2FmCon	Two-family Conversion; originally built as one-family dwelling
       Duplx	Duplex
       TwnhsE	Townhouse End Unit
       TwnhsI	Townhouse Inside Unit
```

.small-code[
&lt;img src="w9d2-conditional-logic_files/figure-html/bldg-type-1.png" width="80%" style="display: block; margin: auto;" /&gt;
]

---


.small[

```r
ames_train %&gt;% count(Bldg_Type) %&gt;% kable()
```



|Bldg_Type |    n|
|:---------|----:|
|OneFam    | 1355|
|TwoFmCon  |   37|
|Duplex    |   43|
|Twnhs     |   56|
|TwnhsE    |  117|


```r
ames_recipe_4 &lt;- 
  recipe(Sale_Price ~ Gr_Liv_Area + Bldg_Type, data = ames_train) %&gt;% 
* step_dummy(Bldg_Type) %&gt;%
  #step_range(all_numeric(), -all_outcomes(), min = 0, max = 1) %&gt;%
  prep()
baked_ames_train &lt;- 
  ames_recipe_4 %&gt;% bake(new_data = ames_train_2)
baked_ames_train %&gt;% head(5) %&gt;% knitr::kable(format = "html")
```

&lt;table&gt;
 &lt;thead&gt;
  &lt;tr&gt;
   &lt;th style="text-align:right;"&gt; Gr_Liv_Area &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Sale_Price &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Bldg_Type_TwoFmCon &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Bldg_Type_Duplex &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Bldg_Type_Twnhs &lt;/th&gt;
   &lt;th style="text-align:right;"&gt; Bldg_Type_TwnhsE &lt;/th&gt;
  &lt;/tr&gt;
 &lt;/thead&gt;
&lt;tbody&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 896 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 105000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1329 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 172000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1629 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 189900 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1604 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 195500 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td style="text-align:right;"&gt; 1804 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 189000 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
   &lt;td style="text-align:right;"&gt; 0 &lt;/td&gt;
  &lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
]

---

## Another kind of model: Decision Trees

&lt;img src="img/Cart_tree_kyphosis.png" width="100%" style="display: block; margin: auto;" /&gt;

---

## Fit a tree to data: same approach, different model


```r
*decision_tree_fit &lt;- decision_tree(mode = "regression", tree_depth = 3) %&gt;%
  set_engine("rpart") %&gt;% 
  fit(Sale_Price ~ Gr_Liv_Area + Bldg_Type, data = ames_train)
```

.pull-left[.small-code[

```r
decision_tree_fit$fit %&gt;% rpart.plot::rpart.plot(roundint = FALSE)
```

&lt;img src="w9d2-conditional-logic_files/figure-html/gr_liv_stub-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]]

.pull-right[.small-code[

```r
sweep_model &lt;- function(model, var_to_sweep, sweep_min, sweep_max, ...) {
  X &lt;- expand_grid(!!enquo(var_to_sweep) := seq(sweep_min, sweep_max, length.out = 500), ...)
  model %&gt;% 
    predict(X) %&gt;% 
    bind_cols(X)
}
ggplot(ames_train, aes(x = Gr_Liv_Area, y = Sale_Price, color = Bldg_Type)) +
  geom_point(alpha = .5, size = .5) +
  geom_line(data = sweep_model(
    decision_tree_fit, Gr_Liv_Area, 0, 4000, Bldg_Type = levels(ames_train$Bldg_Type)),
    mapping = aes(y = .pred))
```

&lt;img src="w9d2-conditional-logic_files/figure-html/decision-tree-example-fit-1.png" width="100%" style="display: block; margin: auto;" /&gt;
]]

---


```r
seq_matching_range &lt;- function(x, length.out = 500) { seq(min(x), max(x), length.out = length.out)}
example_data &lt;- expand_grid(
  Latitude = seq_matching_range(ames_train$Latitude),
  Longitude = seq_matching_range(ames_train$Longitude)
)

*example_data &lt;- decision_tree(mode = "regression", cost_complexity = 1e-6, min_n = 2, tree_depth = 30) %&gt;%
  set_engine("rpart") %&gt;% 
  fit(Sale_Price ~ Latitude + Longitude, data = ames_train) %&gt;% 
  predict(example_data) %&gt;% 
  rename(Sale_Price = .pred) %&gt;% 
  bind_cols(example_data)

ggplot(ames_train_2, aes(x = Longitude, y = Latitude)) +
  geom_raster(data = example_data, mapping = aes(fill = Sale_Price)) +
  geom_point(size = .5)
```

&lt;img src="w9d2-conditional-logic_files/figure-html/show-complex-decision-tree-1.png" width="100%" style="display: block; margin: auto;" /&gt;


---

## Two kinds of regression models

.pull-left[
**Linear Regression**

* *To make a prediction*: multiply terms by constants, sum it all up
* *Conditional logic* by explicitly transforming data to invent special terms
* *Output looks like* lines (or curves, if you add `\(x^2\)` terms)


```
Sale_Price = 
   22643 
   + 18424  * (1 if remodeled)
   + 380368 * Gr_Liv_Area
```

]

.pull-right[

**Decision Tree Regression**

* *To make a prediction*: follow conditional logic rules (determined automatically from data) to output a number.
* *Output looks like* stair-steps

&lt;img src="w9d2-conditional-logic_files/figure-html/gr_liv_stub-2-1.png" width="100%" style="display: block; margin: auto;" /&gt;

]



    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"ratio": "16:9",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>

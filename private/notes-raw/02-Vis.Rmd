
```{r vis-setup, include=FALSE}
library(tidyverse)
theme_set(theme_bw())
set.seed(0)
```

# Visualization

We start with visualization because, well, you can see the results.

## Reading

To design good visuals, you need both *why*s and *how*s. You may have come here for the *how*s, but both are important. Our tools are changing more rapidly than ever, so if we want knowledge that lasts, we really need to know the *why*.

### Why

Read **[Look at Data](https://socviz.co/lookatdata.html)** from Healy "Data Visualization".

The text is wordy but well organized, so your speed reading skills should work well. Look at the examples: can you explain to someone else what those examples show?

### How

Read [**Data Visualization**](https://moderndive.com/2-viz.html) from ModernDive.

Try to actually answer the "Learning Check" questions for yourself. Yes this takes longer than just skimming right past them. But they may show up on a quiz...

## References

### Visualization Design

* A quick guide: the [Graphics Principles](https://graphicsprinciples.github.io/) [*cheat sheet*](https://github.com/GraphicsPrinciples/CheatSheet/blob/master/NVSCheatSheet.pdf).
* [Fundamentals of Data Visualization](https://clauswilke.com/dataviz/)
* DataWrapper's blog has some great advice on [Area charts](https://blog.datawrapper.de/area-charts/), [colors](https://blog.datawrapper.de/beautifulcolors/), and [maps](https://blog.datawrapper.de/choroplethmaps/).
* <https://socviz.co/>

### Implementation

* the [ggplot2 book](https://ggplot2-book.org/index.html)
* the [R Graph Gallery](https://www.r-graph-gallery.com/)

## Tweaks

### Reordering bars in a bar plot

Use `fct_reorder` on the categorical variable.

```{r mass-by-species}
starwars %>% 
  drop_na(height) %>% 
  ggplot(aes(x = height, y = species)) +
  geom_boxplot()
```

```{r species-by-height-median}
starwars %>% 
  drop_na(height) %>% 
  ggplot(aes(x = height, y = fct_reorder(species, height))) +
  geom_boxplot()
```

```{r species-by-height-max}
starwars %>% 
  drop_na(height) %>% 
  ggplot(aes(x = height, y = fct_reorder(species, height, .fun = max))) +
  geom_boxplot()
```

For more info, see the [forcats vignette](https://cran.r-project.org/web/packages/forcats/vignettes/forcats.html).

### Tweaking scales

A common request: scientific notation vs not. A few options:

1. Use different units. e.g., millions of people.

```{r pop-millions-unit}
gapminder::gapminder %>% 
  filter(country == "United States") %>% 
  ggplot(aes(x = year, y = pop / 1e6)) +
  geom_line() +
  labs(y = "Population (millions)")
```

2. Use `scale_y_continuous` with `labels = scales::comma`.

```{r pop-scales-comma}
gapminder::gapminder %>% 
  filter(country == "United States") %>% 
  ggplot(aes(x = year, y = pop)) +
  geom_line() +
  scale_y_continuous(labels = scales::comma) + 
  labs(y = "Population")
```

3. Use `scales::label_number` for even more control (see the help page).

```{r pop-label-number}
gapminder::gapminder %>% 
  filter(country == "United States") %>% 
  ggplot(aes(x = year, y = pop)) +
  geom_line() +
  scale_y_continuous(labels = scales::label_number(scale = 1e-6, suffix = "M")) + 
  labs(y = "Population")
```

### Direct Labels

When you have many lines, colors don't work well for labels. Instead, use two
tricks:

1. Create a data frame with just the rightmost point of each line:

```{r gapminder-directlabels-step1}
gapminder_filtered <-
  gapminder::gapminder %>% 
  group_by(country) %>% 
  filter(max(pop) > 100000000)

last_pop <- gapminder_filtered %>% 
  group_by(country) %>% 
  slice_tail(n = 1)
```


2. Use text geoms to label those points:

```{r gapminder-directlabels-step2}
gapminder_filtered %>% 
  ggplot(aes(x = year, y = pop, color = country)) +
  geom_line() +
  geom_text(
    data = last_pop, aes(label = country), # use different data
    color = "black", hjust = "left" # text starts at "x" and faces right
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, .2))) + # make some room
  scale_y_log10() +
  theme(legend.position = "none") # turn off legend since it's redundant
```

3. Use `ggrepel::geom_text_repel` to keep them from running into each other:

```{r gapminder-directlabels-final}
gapminder_filtered %>% 
  ggplot(aes(x = year, y = pop, color = country)) +
  geom_line() +
  ggrepel::geom_text_repel(
    data = last_pop, aes(label = country),
    color = "black", hjust = "left",
    direction = "y", # only move up or down, never left/right
    segment.alpha = .1, # lighten the connecting lines
    nudge_x = 3,
    seed = 0 # make this plot reproducible.
  ) +
  scale_x_continuous(expand = expansion(mult = c(0, .3))) +
  scale_y_log10() +
  theme(legend.position = "none")
```


See below (and [spaghetti charts](https://www.data-to-viz.com/caveat/spaghetti.html)) for a cleaner alternative.


### Legends and Labels

If you need multiple rows for your legend, you probably have too many different
values. But you can grit your teeth and do it...

```{r multi-row-legend-ick}
starwars %>% skimr::skim()
starwars %>% ggplot(aes(x = height, y = mass, color = species)) +
  geom_point() +
  theme(
    legend.position = "bottom", 
    legend.key.size = unit(0.3, "cm")
#    legend.box.margin = margin(t = 0, r = 0, b = 0, l = 0, unit = "pt")
    ) +
  guides(fill = guide_legend(nrow = 2, byrow = TRUE))

```

### Context and Small Multiples

Showing other data in the background can give context. The easiest way to do this is to filter the data and use multiple layers. (Note that we have to use the `group` aesthetic to draw multiple lines.)

```{r gapminder-just-usa}
gapminder_just_usa <- gapminder::gapminder %>% filter(country == "United States")
gapminder::gapminder %>% 
  ggplot(aes(x = year, y = lifeExp, group = country)) +
    geom_line(alpha = 0.1) +
    geom_line(data = gapminder_just_usa, color = "red")
```

This pairs nicely with faceting; you just need to remove the faceting variable from the background plot. 
We can use this technique to make an easy-to-read version of the spaghetti chart above, using small multiples instead:

```{r gapminder-pop-small-multiples}
gapminder_filtered %>% 
  ggplot(aes(x = year, y = lifeExp)) +
    geom_line(data = gapminder::gapminder %>% rename(country2 = country), mapping = aes(group = country2), alpha = 0.1) +
    geom_line(color = "red") +
    facet_wrap(vars(country), nrow = 2)
```

That example was a bit complex because we needed to maintain the group for the lines. Scatter plots are simpler to code:

```{r health-and-wealth-facet-background}
gapminder::gapminder %>%
  filter(year == 2007) %>% 
  ggplot(aes(x = gdpPercap, y = lifeExp)) +
    geom_point(data = gapminder::gapminder %>% select(-continent), alpha = 0.1, size = .5) +
    geom_point(color = "red", size = .5) +
    facet_wrap(vars(continent)) +
    scale_x_log10()
```


## Maps

### Plotly

This document shows examples of two simple mapping tasks using Plotly. More details are available in the [plotly-r book](https://plotly-r.com/maps.html).

We'll be using the `tidyverse` and the `plotly` package.

```{r include=FALSE}
htmlwidgets::setWidgetIdSeed(1234)
```


```{r message=FALSE}
library(tidyverse)
library(plotly)
```

#### Markers

When you just want to mark something on a map, you can give lat/long coordinates to `add_markers`.

For example, let's use a dataset of US cities:

```{r}
maps::us.cities %>% head()
```

Here's how to draw it on a map.

```{r geo-markers-example}
maps::us.cities %>% 
  # Fix the column names.
  rename(state = country.etc) %>%
  # Keep only larger cities.
  filter(pop > 100000) %>% 
  # Construct the "geo" projection.
  plot_geo() %>%
  # Add state markers
  add_markers(
    # Set marker position.
    x = ~long, 
    y = ~lat, 
    # Set other aesthetics (here, redundantly encode population)
    size = ~pop, 
    color = ~pop,
    # Customize the label.
    text = ~ glue::glue("{name}, population {scales::comma(pop)}"),  
    hoverinfo = "text"
  ) %>% 
  layout(
    # Zoom into just USA.
    geo = list(
      scope = 'usa'
    )
  )
```

#### Choropleths

Plotly has builtin support for countries and US states. Any other granularity requires manually working with GeoJSON files; see
the documentation.

Let's make a world population map. First, let's construct a dataset of the most recent data that Gapminder has for each country:

```{r choropleth-example-data}
library(gapminder)
latest_country_data <- gapminder::gapminder_unfiltered %>%
  arrange(year) %>% 
  group_by(country) %>%
  slice_tail(n = 1) %>% 
  left_join(gapminder::country_codes, by = "country")
```

Now we add a "choropleth" trace. Note that this has the typical problem of choropleth maps and densities; see
[Fundamentals of Data Visualization](https://clauswilke.com/dataviz/geospatial-data.html#choropleth-mapping)
for some discussion of this.

```{r choropleth-example}
latest_country_data %>% 
  plot_geo() %>% 
  add_trace(
    type = "choropleth",
    # Specify that the "country" column contains the country names.
    locations = ~country,
    locationmode = "country names",
    # Use fill to show population. (I don't know why it's called 'z' and not 'fill'.)
    z = ~pop
  )
```



```{r include=FALSE}
#geojson <- pins::pin("https://raw.githubusercontent.com/datasets/geo-countries/master/data/countries.geojson") %>% 
#jsonlite::fromJSON(simplifyVector = FALSE)
```
